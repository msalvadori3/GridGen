%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{GridGen: an Elliptical Grid Generator}
\date{Feb 28, 2018}
\release{}
\author{Marc Salvadori}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Author: Marc Salvadori

Email: \sphinxhref{mailto:msalvadori3@gatech.edu}{msalvadori3@gatech.edu}

The basic idea behind grid generation is the creation of the transformation laws between the physical space and the computational space. The different techniques to generate a grid can be summarized in the following diagram.

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.5]{{grid_diagram}.png}\hspace*{\fill}}

Elliptic grid generation is one of several methods used to generate structured grids for complex geometries. Algebraic methods are one commonly used alternative, and hyperbolic systems of equations are sometimes used, particularly for external flows. In this project it is required solve a pair of Laplace/Poisson equations to generate the mesh. Rather than work in the physical domain where the geometry is complicated and the equations are simple, we prefer to work in the computational domain where just the opposite is true. Once we have done our work in the computational domain, we bring the results back to the physical domain for viewing.

The overall procedure to generate a grid is as follows:
\begin{enumerate}
\item {} 
Establish the transformation relations between the physical space and the computational space.

\item {} 
Transform the governing equations and the boundary conditions into the computational space.

\item {} 
Solve the equations in the computational space using the uniformly spaced rectangular grid.

\item {} 
Perform a reverse transformation to represent the flow properties in the physical space.

\end{enumerate}


\chapter{Contents}
\label{\detokenize{index:contents}}\label{\detokenize{index:documentaion-for-elliptic-grid-generation}}

\section{Project Description}
\label{\detokenize{background::doc}}\label{\detokenize{background:project-description}}

\subsection{Given task}
\label{\detokenize{background:given-task}}
In this exercise you will generate an inviscid, 2-D computational grid around a modified NACA 00xx series airfoil in a channel. The thickness distribution of a modified NACA 00xx series airfoil is given by:
\begin{equation*}
\begin{split}y(x) = \pm 5t [0.2969 \sqrt{x_{int}x} - 0.126 x_{int} x - 0.3516 (x_{int}x)^{2} + 0.2843(x_{int}x)^{3} - 0.1015 (x_{int}x)^{4}]\end{split}
\end{equation*}
where the “\(+\)” sign is used for the upper half of the airfoil, the “\(-\)” sign is used for the lower half and \(x_{int} = 1.008930411365\). Note that in the expression above \(x\), \(y\), and \(t\) represent values which have been normalized by the airfoil by the airf
oil chord.

A sketch of the computational domain is shown below:
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.6]{{CP1_compute_domain}.png}
\end{figure}

Each grid point can be described by \((x,y)\) location or \((i,j)\) location where \(i\) is the index in the \(\xi\) direction and the \(j\) index is in the \(\eta\) direction. The grid should have imax=41 points in the \(\xi\) direction and jmax=19 points in the \(\eta\) direction. The coordinates of points A-F shown in the figure are given in the following table:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

Point
&
\((i,j)\)
&
\((x,y)\)
&\\
\hline
A
&
(1,19)
&
(-0.8,1.0)
&\\
\hline
B
&
(41,19)
&
(1.8,1.0)
&\\
\hline
C
&
(41,1)
&
(1.8,0.0)
&\\
\hline
D
&
(31,1)
&
(1.0,0.0)
&
(trailing edge)
\\
\hline
E
&
(11,1)
&
(0.0,0.0)
&
(leading edge)
\\
\hline
F
&
(1,1)
&
(-0.8,0.0)
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Algebraic Grid}
\label{\detokenize{background:algebraic-grid}}
To complete this project you will first generate a grid using algebraic methods. Use uniform spacing in the \(x\) direction along FE, along ED, and along DC. (However, note that the spacing in the \(x\) direction along FE and DC will be different from the spacing along ED). Use uniform spacing in the \(x\) direction along AB. (However, note that the spacing in the \(x\) direction along AB will be different from that along FE, ED, and DC). For the interior points of the initial algebraic grid use a linear interpolation (in computational space) of the boundary \(x\) values:
\begin{equation*}
\begin{split}x(i,j) = x(i,1) + \left ( \frac{j-1}{jmax-1} \right ) [x(i,jmax) - x(i,1)]\end{split}
\end{equation*}
Use the following stretching formula to define the spacing in the \(y\) direction:
\begin{equation*}
\begin{split}y(i,j) = y(i,1) - \frac{y(i,jmax)-y(i,1)}{C_{y}} ln \left [ 1 + (e^{-C_{y}} - 1) \left ( \frac{j-1}{jmax-1} \right ) \right ]\end{split}
\end{equation*}
where \(C_{y}\) is a parameter that controls the amount of grid clustering in the \(y\)-direction. (If nearly uniform spacing were desired we would use \(C_{y}\) = 0.001).

The algebraic grid generated now serves as the initial condition for the subroutines which generate the elliptic grid. The bounday values of the initial algebraic grid will be the same as those of the final elliptic grid.


\subsubsection{Elliptic Grid}
\label{\detokenize{background:elliptic-grid}}
The elliptic grid will be generated by solving Poisson Equations:
\begin{align*}\!\begin{aligned}
\xi_{xx} + \xi_{yy} = P(\xi,\eta)\\
\eta_{xx} + \eta_{yy} = Q(\xi,\eta)\\
\end{aligned}\end{align*}
where the source terms,
\begin{align*}\!\begin{aligned}
A_{1} (x_{\xi\xi} + \phi x_{\xi}) - 2A_{2} x_{\xi\eta} + A_{3}(x_{\eta\eta} + \psi x_{\eta}) = 0\\
A_{1} (y_{\xi\xi} + \phi y_{\xi}) - 2A_{2} y_{\xi\eta} + A_{3}(y_{\eta\eta} + \psi y_{\eta}) = 0\\
\end{aligned}\end{align*}
where the \(A\)‘s must be defined by mathmatical manipulation.

On the boundaries, \(\phi\) and \(\psi\) are defined as follows:
\begin{align*}\!\begin{aligned}
\text{On } j = 1 \text{ and } j = jmax: \text{  }\phi = \begin{cases} -\frac{x_{\xi\xi}}{x_{\xi}} & \text{ if } |x_{\xi}| > |y_{\xi}| \\ -\frac{y_{\xi\xi}}{y_{\xi}} & \text{ if } |x_{\xi}| \leq |y_{\xi}| \end{cases}\\
\text{On } i = 1 \text{ and } i = imax: \text{  }\psi = \begin{cases} -\frac{x_{\eta\eta}}{x_{\eta}} & \text{ if } |x_{\eta}| > |y_{\eta}| \\ -\frac{y_{\eta\eta}}{y_{\eta}} & \text{ if } |x_{\eta}| \leq |y_{\eta}| \end{cases}\\
\end{aligned}\end{align*}
At interior points, \(\phi\) and \(\psi\) are found by linear interpolation (in computational space) of these boundary values. For example,
\begin{equation*}
\begin{split}\psi_{i,j} = \psi_{1,j} + \frac{i-1}{imax-1} \left ( \psi_{imax,j} - \psi_{1,j} \right )\end{split}
\end{equation*}

\subsection{Deliverables}
\label{\detokenize{background:deliverables}}
Demonstrate your solver by generating 5 grids (each with 41x19 grid points):


\subsubsection{Grid \#1}
\label{\detokenize{background:grid-1}}
Initial algebraic grid, non-clustered (\(C_{y}\) = 0.001)


\subsubsection{Grid \#2}
\label{\detokenize{background:grid-2}}
Initial algebraic grid, clustered (\(C_{y}\) = 2.0)


\subsubsection{Grid \#3}
\label{\detokenize{background:grid-3}}
Elliptic grid, clustered (\(C_{y}\) = 2.0), no control terms (\(\phi\) = \(\psi\) = 0)


\subsubsection{Grid \#4}
\label{\detokenize{background:grid-4}}
Elliptic grid, clustered (\(C_{y}\) = 2.0), with control terms


\subsubsection{Grid \#5}
\label{\detokenize{background:grid-5}}
Now, use your program to generate the best grid you can for inviscid , subsonic flow in the geometry shown. You must keep imax = 41, jmax = 19 and not change the size or shape of the outer and wall boundaries. You may, however, change the grid spacing along any and all of the boundaries and use different levels of grid clustering wherever you think it is appropriate.


\section{Setup}
\label{\detokenize{setup:setup}}\label{\detokenize{setup:setup-gridgen}}\label{\detokenize{setup::doc}}

\subsection{Setting up a Grid}
\label{\detokenize{setup:setting-up-a-grid}}\label{\detokenize{setup:id1}}

\subsection{Code Structure}
\label{\detokenize{setup:code-structure}}\label{\detokenize{setup:structure}}
The {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} code is divided into three major parts:
\begin{enumerate}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Input}: User input is entered into a file called \sphinxcode{input\_file.xml}.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Main Program}: The main program for solving the elliptical grid is \sphinxcode{gridgen.F90} in the \sphinxcode{\textless{}parent directory\textgreater{}/src/main} folder.
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Output}: Once the code is run, the results are stored in the \sphinxcode{\textless{}parent directory\textgreater{}/output/} folder.
\end{DUlineblock}

\end{enumerate}


\subsection{Input File}
\label{\detokenize{setup:input}}\label{\detokenize{setup:input-file}}
The inputs for GridGenerator are specified in the \sphinxcode{input\_file.xml}. The input file is accessed as follows:
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}GridGen\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Open the input file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} vi input\PYGZus{}file.xml
\end{sphinxVerbatim}

\item {} 
The main parts of the input file are shown below

\end{enumerate}

The input file is divided into different parts. The geometry is set in the \sphinxcode{\textless{}geometry\textgreater{}} module, which is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}geometry}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}x1}\PYG{n+nt}{\PYGZgt{}}\PYGZhy{}0.8\PYG{n+nt}{\PYGZlt{}/x1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}y1}\PYG{n+nt}{\PYGZgt{}}0.0\PYG{n+nt}{\PYGZlt{}/y1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}x2}\PYG{n+nt}{\PYGZgt{}}1.8\PYG{n+nt}{\PYGZlt{}/x2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}y2}\PYG{n+nt}{\PYGZgt{}}0.0\PYG{n+nt}{\PYGZlt{}/y2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}x3}\PYG{n+nt}{\PYGZgt{}}\PYGZhy{}0.8\PYG{n+nt}{\PYGZlt{}/x3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}y3}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/y3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}x4}\PYG{n+nt}{\PYGZgt{}}1.8\PYG{n+nt}{\PYGZlt{}/x4\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}y4}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/y4\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}FEsize}\PYG{n+nt}{\PYGZgt{}}11\PYG{n+nt}{\PYGZlt{}/FEsize\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}DCsize}\PYG{n+nt}{\PYGZgt{}}11\PYG{n+nt}{\PYGZlt{}/DCsize\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Geosize}\PYG{n+nt}{\PYGZgt{}}21\PYG{n+nt}{\PYGZlt{}/Geosize\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Geoptx1}\PYG{n+nt}{\PYGZgt{}}0.0\PYG{n+nt}{\PYGZlt{}/Geoptx1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Geopty1}\PYG{n+nt}{\PYGZgt{}}0.0\PYG{n+nt}{\PYGZlt{}/Geopty1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Geoptx2}\PYG{n+nt}{\PYGZgt{}}1.0\PYG{n+nt}{\PYGZlt{}/Geoptx2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Geopty2}\PYG{n+nt}{\PYGZgt{}}0.0\PYG{n+nt}{\PYGZlt{}/Geopty2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}imax}\PYG{n+nt}{\PYGZgt{}}41\PYG{n+nt}{\PYGZlt{}/imax\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}jmax}\PYG{n+nt}{\PYGZgt{}}19\PYG{n+nt}{\PYGZlt{}/jmax\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/geometry\PYGZgt{}}
\end{sphinxVerbatim}

For setup of the solver, most of the inputs are set in the \sphinxcode{\textless{}setup\textgreater{}} module. A  snippet of this module is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}setup}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Project}\PYG{n+nt}{\PYGZgt{}}2D\PYGZus{}Grid\PYGZus{}Generator\PYG{n+nt}{\PYGZlt{}/Project\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}nmax}\PYG{n+nt}{\PYGZgt{}}500\PYG{n+nt}{\PYGZlt{}/nmax\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}iControl}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/iControl\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Cy}\PYG{n+nt}{\PYGZgt{}}2.0\PYG{n+nt}{\PYGZlt{}/Cy\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}RMSres}\PYG{n+nt}{\PYGZgt{}}1.0e\PYGZhy{}6\PYG{n+nt}{\PYGZlt{}/RMSres\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/setup\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Compilation}
\label{\detokenize{setup:compilation}}\label{\detokenize{setup:id2}}
The following sequence of commands is used to compile a single simulation.
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}GridGen\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Clean existing results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean heavy
\end{sphinxVerbatim}

This command removes the existing files in the output folder \sphinxcode{\textbar{}GridGen\textbar{}/output/} and deletes the object files from previous compilations. \sphinxstylestrong{Backup any required results before using this command.}

\item {} 
Set working directory path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u set\PYGZus{}path
\end{sphinxVerbatim}

This command sets the working directory path

\item {} 
Set the output directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u create\PYGZus{}subdirectories
\end{sphinxVerbatim}

\item {} 
Compile the build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e configure
\end{sphinxVerbatim}

An empty CMake window opens. Press \sphinxcode{{[}c{]}} on the keyboard to configure the program.
\begin{quote}
\begin{description}
\item[{This brings up the CMake window. There are two options for the \sphinxstyleliteralstrong{CMAKE\_BUILD\_TYPE} :}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{Release}: This compiles the program in regular mode; debugging flags are disabled.

\item {} 
\sphinxcode{Debug}:   This compiles the program in debug mode; errors and warnings are displayed on the terminal.

\end{itemize}

\end{description}

Press \sphinxcode{{[}Enter{]}} on the keyboard to edit the option (to change from \sphinxcode{Release} to \sphinxcode{Debug} or vice versa)

The file \sphinxstyleliteralstrong{grid.x} will now be generated in the parent directory
\end{quote}

\item {} 
Execute the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./grid.x
\end{sphinxVerbatim}

This command runs the program. If Debug mode is enabled in \sphinxstyleliteralstrong{GRIDGEN\_COMPILE\_DEFS}, appropriate output is printed on the Terminal screen.

\end{enumerate}


\subsection{Results}
\label{\detokenize{setup:results}}\label{\detokenize{setup:id3}}
The results are stored in the \sphinxcode{output/} folder inside the parent directory. The output directory contains several files \sphinxstylestrong{.dat} and \sphinxstylestrong{.tec} where the calculations are written. In addition, there is also a \sphinxcode{output/plot} folder, where figures from the calculated data are plotted. To plot the results. open the inputfile and enter the name of the \sphinxstylestrong{.dat} file that was generated in the \sphinxcode{files} entry (as shown below).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}PostProcessing}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}plot}\PYG{n+nt}{\PYGZgt{}}
       \PYG{n+nt}{\PYGZlt{}files}\PYG{n+nt}{\PYGZgt{}}RESULTDATFILE\PYG{n+nt}{\PYGZlt{}/files\PYGZgt{}}
       ...
    \PYG{n+nt}{\PYGZlt{}/plot\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/PostProcessing\PYGZgt{}}
\end{sphinxVerbatim}

Then, from the parent directory execute the following command to plot the results using {\color{red}\bfseries{}\textbar{}GridGen\textbar{}}’s inbuilt plotting utility:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot
\end{sphinxVerbatim}

This will generate the RMS line plots from the results, which will be stored in the \sphinxcode{output/plot} folder.


\section{Input File}
\label{\detokenize{inputfile::doc}}\label{\detokenize{inputfile:input-file}}\label{\detokenize{inputfile:inputfile}}
The input file is central location for setting any and all parameters for all the features in {\color{red}\bfseries{}\textbar{}GridGen\textbar{}}. Depending on the type of operation being performed on {\color{red}\bfseries{}\textbar{}GridGen\textbar{}}, the relevant input options are set in the input file.


\subsection{Structure of the Geometry Module}
\label{\detokenize{inputfile:str-geometry}}\label{\detokenize{inputfile:structure-of-the-geometry-module}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{geometry}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{x1}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{x1}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{y1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{y1}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{x2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{x2}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{y2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{y2}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{x3}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{x3}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{y3}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{y3}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{x4}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.8}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{x4}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{y4}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{y4}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{FEsize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{FEsize}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{DCsize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{DCsize}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Geosize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{21}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Geosize}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Geoptx1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Geoptx1}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Geopty1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Geopty1}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Geoptx2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Geoptx2}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Geopty2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Geopty2}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{imax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{41}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{imax}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{jmax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{19}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{jmax}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{geometry}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Structure of Setup Module}
\label{\detokenize{inputfile:str-setup}}\label{\detokenize{inputfile:structure-of-setup-module}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{setup}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{Project}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{n}{D\PYGZus{}Grid\PYGZus{}Generator}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Project}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{nmax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{500}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{nmax}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{iControl}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{iControl}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{Cy}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{2.0}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Cy}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{RMSres}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.0e\PYGZhy{}6}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{RMSres}\PYG{o}{\PYGZgt{}}
 \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{setup}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Structure of Postprocessing Modules}
\label{\detokenize{inputfile:str-post}}\label{\detokenize{inputfile:structure-of-postprocessing-modules}}\phantomsection\label{\detokenize{inputfile:plot-input}}
{\color{red}\bfseries{}\textbar{}GridGen\textbar{}} also allows the user to graphically visualize the results through the use of graphs and contours. Inputs to this plotting utility are also provided through the input file. The relevant block for this utility is shown below, and linked to the dedicated plotting utility page.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{PostProcessing}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{n}{plot}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{iPost}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{iPost}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{Method}\PYG{o}{\PYGZgt{}}\PYG{n}{TecPlot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{Method}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{files}\PYG{o}{\PYGZgt{}}\PYG{n}{rmslog}\PYG{o}{.}\PYG{n}{dat}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{files}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{style}\PYG{o}{\PYGZgt{}}\PYG{n}{k} \PYG{o}{+}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{style}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{label}\PYG{o}{\PYGZgt{}}\PYG{n}{Grid}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{label}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{LegendFontSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{16}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{LegendFontSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{FigureSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10} \PYG{l+m+mi}{7}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{FigureSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{AxisLabelSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{21}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AxisLabelSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{AxisTitleSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{22}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{AxisTitleSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{XTickSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{23}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{XTickSize}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{YTickSize}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{24}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{YTickSize}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{plot}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{PostProcessing}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{Code development}
\label{\detokenize{devel:code-development}}\label{\detokenize{devel::doc}}
The current project is for developing elliptic grid generator in 2-dimensional domain. Hereafter, the program developed in this project is called ‘GridGen’.


\subsection{GridGen Code summary}
\label{\detokenize{devel:gridgen-code-summary}}
The present project is to make a grid-generator for 2-D computational domain around a modified NACA 00xx series airfoil in a channel.

The source code contains the following directories:
\begin{itemize}
\item {} 
io - input/output related routines

\item {} 
main - main program driver

\item {} 
math - thomas algorithm

\item {} 
modules - main grid generator solver routines

\item {} 
utils - list of useful FORTRAN utilities used within the program

\item {} 
gridpy - python wrapper for gridgen main program

\end{itemize}
\begin{quote}

Also a ‘CMakeLists.txt’ file is also included for cmake compiling.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd GridGen/src/
\PYGZdl{} ls
\PYGZdl{} CMakeLists.txt  io  main math modules utils gridpy
\end{sphinxVerbatim}

The \sphinxstylestrong{io} folder has \sphinxstylestrong{io.F90} file which contains \sphinxstylestrong{ReadInput(inputData)} subroutine. It also includes \sphinxstylestrong{input\_file\_xml} which describes the structure of the user run-time input file located in the main ‘src’ directory, and \sphinxstylestrong{output.F90} for storing data in bothb Tecplot and Python format.

The \sphinxstylestrong{main} folder is only used for containing the code driver file. The main routines is run by \sphinxstylestrong{gridgen.F90} which calls important subroutines from the rest of folders.


\subsection{Details of GridGen development}
\label{\detokenize{devel:details-of-gridgen-development}}
The GridGen code is made for creating 2-D computational domain with pre-described points value along the 2D airfoil geometry. The schematic below shows the flow chart of how the GridGen code runs.

The source code shown below is \sphinxstylestrong{gridgen.F90} and it calls skeletal subroutines for generating grid structure. The main features of the main code is to (1) read input file, (2) make initialized variable arrays, (3) set initial algebraic grid points, (4) create elliptic grid points, and (5) finally write output files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PROGRAM} \PYG{n}{main}

      \PYG{n}{USE} \PYG{n}{xml\PYGZus{}data\PYGZus{}input\PYGZus{}file}
      \PYG{n}{USE} \PYG{n}{GridSetup\PYGZus{}m}\PYG{p}{,}\PYG{n}{ONLY}\PYG{p}{:}\PYG{n}{InitGrid}\PYG{p}{,}\PYG{n}{GridInternal}\PYG{p}{,}\PYG{n}{EndVars}
      \PYG{n}{USE} \PYG{n}{parameters\PYGZus{}m}\PYG{p}{,}\PYG{n}{ONLY}\PYG{p}{:}\PYG{n}{wp}
      \PYG{n}{USE} \PYG{n}{SimVars\PYGZus{}m}\PYG{p}{,}\PYG{n}{ONLY}\PYG{p}{:}\PYG{n}{fileLength}
      \PYG{n}{USE} \PYG{n}{GridTransform\PYGZus{}m}\PYG{p}{,}\PYG{n}{ONLY}\PYG{p}{:} \PYG{n}{InitArrays}\PYG{p}{,}\PYG{n}{CalcCoeff}\PYG{p}{,}\PYG{n}{PhiPsi}\PYG{p}{,}\PYG{n}{TriDiag}\PYG{p}{,}\PYG{n}{Jacobian}\PYG{p}{,}\PYG{o}{\PYGZam{}}
              \PYG{n}{EndArrays}
      \PYG{n}{USE} \PYG{n}{output\PYGZus{}m}\PYG{p}{,}\PYG{n}{ONLY}\PYG{p}{:}\PYG{n}{WritePlotFile}\PYG{p}{,}\PYG{n}{WriteRMS}

      \PYG{n}{IMPLICIT} \PYG{n}{NONE}

      \PYG{n}{TYPE}\PYG{p}{(}\PYG{n}{input\PYGZus{}type\PYGZus{}t}\PYG{p}{)} \PYG{p}{:}\PYG{p}{:} \PYG{n}{inputData}
      \PYG{n}{CHARACTER}\PYG{p}{(}\PYG{n}{LEN}\PYG{o}{=}\PYG{n}{fileLength}\PYG{p}{)} \PYG{p}{:}\PYG{p}{:}\PYG{n}{output}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}
      \PYG{n}{CHARACTER}\PYG{p}{(}\PYG{n}{LEN}\PYG{o}{=}\PYG{n}{fileLength}\PYG{p}{)} \PYG{p}{:}\PYG{p}{:} \PYG{n}{rmsout} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rmslog.dat}\PYG{l+s+s1}{\PYGZsq{}}
      \PYG{n}{INTEGER} \PYG{p}{:}\PYG{p}{:} \PYG{n}{i}
      \PYG{n}{REAL}\PYG{p}{(}\PYG{n}{KIND}\PYG{o}{=}\PYG{n}{wp}\PYG{p}{)} \PYG{p}{:}\PYG{p}{:} \PYG{n}{rms}

      \PYG{n}{CALL} \PYG{n}{InitGrid}\PYG{p}{(}\PYG{n}{inputData}\PYG{p}{)}
      \PYG{n}{CALL} \PYG{n}{InitArrays}
      \PYG{n}{CALL} \PYG{n}{Jacobian}
      \PYG{n}{CALL} \PYG{n}{WritePlotFile}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{InitGrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Jacobian}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Phi}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Psi}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{inputData}\PYG{p}{)}
      \PYG{n}{IF} \PYG{p}{(}\PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{iControl} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{CALL} \PYG{n}{PhiPsi}
      \PYG{n}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Solving Elliptical Grid...............}\PYG{l+s+s1}{\PYGZsq{}}
      \PYG{n}{DO} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{nmax}
                \PYG{n}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IT = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}
                \PYG{n}{CALL} \PYG{n}{CalcCoeff}
                \PYG{n}{CALL} \PYG{n}{TriDiag}\PYG{p}{(}\PYG{n}{rms}\PYG{p}{)}
                \PYG{n}{CALL} \PYG{n}{WriteRMS}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{rms}\PYG{p}{,}\PYG{n}{rmsout}\PYG{p}{)}
                \PYG{n}{IF} \PYG{p}{(}\PYG{n}{rms} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{RMSres}\PYG{p}{)} \PYG{n}{EXIT}
      \PYG{n}{ENDDO}
      \PYG{n}{CALL} \PYG{n}{Jacobian}
      \PYG{n}{CALL} \PYG{n}{WritePlotFile}\PYG{p}{(}\PYG{n}{output}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Jacobian}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Phi}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Psi}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{inputData}\PYG{p}{)}
      \PYG{n}{CALL} \PYG{n}{EndArrays}
      \PYG{n}{CALL} \PYG{n}{EndVars}

\PYG{n}{END} \PYG{n}{PROGRAM} \PYG{n}{main}
\end{sphinxVerbatim}


\subsubsection{Creation of algebraic grid points}
\label{\detokenize{devel:creation-of-algebraic-grid-points}}
The code starts to run by reading the important input parameters defined by the user in the \sphinxstylestrong{input\_file.xml} file. The input data file first contains all the details geometrical description of our grid points. Then the code reads airfoil geometry data from this input file, which provides the bottom edge points of the domain. The input file also contains four vertex points in \((x,y)\) coordinates. Thus those points forms a 2-dimensional surface. Based on these boundary grid points, the code runs with Algebratic grid generating subroutine and gives initial conditions for elliptic solution for grid transformation.

The \sphinxstylestrong{gridgen.F90} file first refers to \sphinxstylestrong{InitGrid} subroutine defined in \sphinxstylestrong{GridSetup.F90} file. The main function of this routine is to call again multiple subroutines defined in same file. The subroutine definition shown below summarizes the how the code runs for the grid initialization:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUBROUTINE} \PYG{n}{InitGrid}\PYG{p}{(}\PYG{n}{inputData}\PYG{p}{)}

        \PYG{n}{USE} \PYG{n}{xml\PYGZus{}data\PYGZus{}input\PYGZus{}file}
        \PYG{n}{USE} \PYG{n}{io\PYGZus{}m}\PYG{p}{,} \PYG{n}{ONLY}\PYG{p}{:} \PYG{n}{ReadInput}

        \PYG{n}{IMPLICIT} \PYG{n}{NONE}

        \PYG{n}{TYPE}\PYG{p}{(}\PYG{n}{input\PYGZus{}type\PYGZus{}t}\PYG{p}{)} \PYG{p}{:}\PYG{p}{:} \PYG{n}{inputData}

        \PYG{n}{CALL} \PYG{n}{ReadInput}\PYG{p}{(}\PYG{n}{inputData}\PYG{p}{)}
        \PYG{n}{CALL} \PYG{n}{InitVars}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{CALL} \PYG{n}{BottomEdge}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{CALL} \PYG{n}{SetBCs}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{CALL} \PYG{n}{GridInternal}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{END} \PYG{n}{SUBROUTINE} \PYG{n}{InitGrid}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxstylestrong{ReadGridInput}: Reads  user defined variables and parameters for grid configuration.

\item {} 
\sphinxstylestrong{InitVars}: Initialize the single- and multi-dimensional arrays and set their size based on the input parameters.

\item {} 
\sphinxstylestrong{BottomEdge}: Generate point values for airfoil geometry.

\item {} 
\sphinxstylestrong{SetBcs}: Generate grid points along 4 edges of the computational domain.

\item {} 
\sphinxstylestrong{GridInternal}: Based on grid points along the edges and surfaces, this routine will create interior grid points that are aligned with user-defined grid point interpolations.

\end{itemize}


\subsubsection{Creaction of elliptic grid points}
\label{\detokenize{devel:creaction-of-elliptic-grid-points}}
In order to determine the elliptic grid points with the pre-specified boundary points, the following Poisson equations, which is given in previous \sphinxstylestrong{Project description} section, have to be resolved numerically. The coefficients of the equations can be determined by:
\begin{align*}\!\begin{aligned}
{\alpha}=x_{\eta}^{2} + y_{\eta}^{2}\\
{\beta}=x_{\xi}x_{\eta} + y_{\xi}y_{\eta}\\
{\gamma}=x_{\xi}^{2} + y_{\xi}^{2}\\
\end{aligned}\end{align*}
Then, applying finite difference approximation to the governing equations can be transformed into the linear system of equations. The arranged matrix form of equations shown below can be solved for unknown implicitly at every pseudo-time level. At every time loop, the code updates the coefficients composed of \(\phi\) and \(\psi\), and adjacent points. The detailed relations of each coefficients are not shown here for brevity.
\begin{align*}\!\begin{aligned}
a_{i,j} x_{i-1,j}^{n+1} + b_{i,j} x_{i,j}^{n+1} + c_{i,j} x_{i+1,j}^{n+1} = d_{i,j}\\
e_{i,j} y_{i-1,j}^{n+1} + f_{i,j} y_{i,j}^{n+1} + g_{i,j} y_{i+1,j}^{n+1} = h_{i,j}\\
\end{aligned}\end{align*}
Above equations can be numerically evaluated by the following descritized expressions:
\begin{align*}\!\begin{aligned}
a_{i,j} = e_{i,j} = {\alpha}_{\text{ }i,j}^{n}  \left(1 - \frac{\phi_{i,j}^{n}}{2} \right)\\
b_{i,j} = f_{i,j} = -2 \left({\alpha}_{\text{ }i,j} + {\gamma}_{\text{ }i,j} \right)\\
c_{i,j} = g_{i,j} = {\alpha}_{\text{ }i,j}^{n}  \left(1 + \frac{\phi_{i,j}^{n}}{2} \right)\\
e_{i,j} = \frac{{\beta}_{\text{ }i,j}^{n}}{2} \left(x_{i+1,j}^{n} - x_{i+1,j-1}^{n+1} - x_{i-1,j+1}^{n} - x_{i-1,j-1}^{n+1} \right) - {\gamma}_{\text{ }i,j}^{n} \left( x_{i,j+1}^{n} + x_{i,j-1}^{n+1} \right) - \frac{{\beta}_{\text{ }i,j}^{n}}{2} \psi_{i,j}^{n} \left( x_{i,j+1}^{n} - x_{i,j-1}^{n+1} \right)\\
h_{i,j} = \frac{{\beta}_{\text{ }i,j}^{n}}{2} \left(y_{i+1,j}^{n} - y_{i+1,j-1}^{n+1} - y_{i-1,j+1}^{n} - y_{i-1,j-1}^{n+1} \right) - {\gamma}_{\text{ }i,j}^{n} \left( y_{i,j+1}^{n} + y_{i,j-1}^{n+1} \right) - \frac{{\beta}_{\text{ }i,j}^{n}}{2} \psi_{i,j}^{n} \left( y_{i,j+1}^{n} - y_{i,j-1}^{n+1} \right)\\
\end{aligned}\end{align*}
where \(n\) and \(n+1\) indicate pseudo time index. Thus above equations will update grid point coordinates for \(n+1\) time level by referring to already resolved \(n\) time level solution. Note that the pseudo time looping goes along the successive \(j\)-constant lines. Therefore, when writing the code, time level index in above equations was not considered as a separate program variable because \(j-1\) constant line is already updated in the previous loop.

The expressions above are only evaluted in the interior grid points. The points on the boundaries are evaluated seprately by applying given solutions as problem handout.

Once initial algebraic grid points are created, the code is ready to make elliptic grid points with some control terms in terms of \(\phi\) and \(\psi\). \sphinxstylestrong{gridgen.F90} file contains the necessary subroutine calls to evaluate the elipptical grid  as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IF} \PYG{p}{(}\PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{iControl} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{CALL} \PYG{n}{PhiPsi}
\PYG{n}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Solving Elliptical Grid...............}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{DO} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{nmax}
          \PYG{n}{WRITE}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IT = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}
          \PYG{n}{CALL} \PYG{n}{CalcCoeff}
          \PYG{n}{CALL} \PYG{n}{TriDiag}\PYG{p}{(}\PYG{n}{rms}\PYG{p}{)}
          \PYG{n}{CALL} \PYG{n}{WriteRMS}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{rms}\PYG{p}{,}\PYG{n}{rmsout}\PYG{p}{)}
          \PYG{n}{IF} \PYG{p}{(}\PYG{n}{rms} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{inputData}\PYG{o}{\PYGZpc{}}\PYG{n}{setup}\PYG{o}{\PYGZpc{}}\PYG{n}{RMSres}\PYG{p}{)} \PYG{n}{EXIT}
\PYG{n}{ENDDO}
\end{sphinxVerbatim}

Before going into the main loop for solving poisson equations, the code calculate control terms with \(\phi\) and \(\psi\) only if the user defines the option in the \sphinxstylestrong{input\_file.xml} file. Even though the assigned project made an assumption of linear interpolated distribution of \(\phi\) and \(\psi\) at interior points, the GridGen code is designed to allow \(\phi\) and \(\psi\) be weighted in \(j\) and \(i\) directions, respectively. This effect is made by the grid stretching formula.

Here, main DO-loop routine goes with setup of coefficients of governing equations and Thomas loop. The Thomas loop operates with line Gauss-Siedel method for resolving unknown variables, \(x\) and \(y\), with tri-diagonal matrix of coefficients of finite difference approximation equation in a \(j\) = constant line.


\subsubsection{RMS residual}
\label{\detokenize{devel:rms-residual}}
In order to avoid infinite time-looping for the Thomas method, the GridGen code employs the following definition of RMS residual based on the new (\(n+1\)) and old(\(n\)) values of grid point coordinates.
\begin{equation*}
\begin{split}\text{RMS}^{n} = \sqrt{\frac{1}{N} \sum_{i=2}^{imax-1} \sum_{jmax-1}^{j=2} \left[\left(x_{i,j}^{n+1} - x_{i,j}^{n} \right)^{2} + \left(y_{i,j}^{n+1} - y_{i,j}^{n} \right)^{2} \right]}\end{split}
\end{equation*}
where \(N = 2x(\text{imax}-2) x (\text{jmax}-2)\) and the RMS criterion is user-specified as as small number or by default it is set as: \(1\text{x}10^{-6}\). In this code, the convergend is assumed to be achieved when RMS residual is less than the RMS criterion.


\section{GridPy}
\label{\detokenize{gridpy::doc}}\label{\detokenize{gridpy:gridpy}}
GridPy is a python-based library of {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} that is developed to assist the user with i/o procedures, utilities and code options/testing. In the following, the commands are listed by category and discussion is provided in each respective section.


\subsection{Compilation Options}
\label{\detokenize{gridpyfiles/compile::doc}}\label{\detokenize{gridpyfiles/compile:compilation-options}}
{\color{red}\bfseries{}\textbar{}GridGen\textbar{}} has several builtin compilation options, that can be accessed through the command \sphinxstyleliteralstrong{./setup.py -e} and the  utilities that can be accessed using \sphinxstyleliteralstrong{./setup.py -u}. These are described here.


\subsubsection{Configure}
\label{\detokenize{gridpyfiles/compile:configure}}
The default method for compiling {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} from scratch is using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e configure gridgen
\end{sphinxVerbatim}

This generates a CCMake window with configuration options that can be chosen by the user. Refer to the {\hyperref[\detokenize{setup:compilation}]{\sphinxcrossref{\DUrole{std,std-ref}{compilation section}}}} of the {\hyperref[\detokenize{setup:setup-gridgen}]{\sphinxcrossref{\DUrole{std,std-ref}{\textbar{}GridGen\textbar{} Setup page}}}} for details on using this method.


\subsubsection{Compile}
\label{\detokenize{gridpyfiles/compile:compile}}
This option should be used only if {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} has been configured first (using \sphinxcode{-e configure}). This recompiles the code with any changes, while retaining the build directory and related objects. It can be executed using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}e compile gridgen
\end{sphinxVerbatim}


\subsection{Setting the path}
\label{\detokenize{gridpyfiles/compile:setting-the-path}}
{\color{red}\bfseries{}\textbar{}GridGen\textbar{}} requires the path to the working directory be set every time a run is executed from scratch (i.e. after clearing all the compilations). The {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} executable \sphinxcode{grid.x} will not run without this path set. To set the path, compile/configure {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} using any of the options, and then run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u set\PYGZus{}path
\end{sphinxVerbatim}


\subsection{Cleaning commands}
\label{\detokenize{gridpyfiles/compile:cleaning-commands}}
After completion of a simulation, or before running a fresh simulation, {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} can be cleared of compiled objects, results and other files. There are three variants to clean {\color{red}\bfseries{}\textbar{}GridGen\textbar{}}. The first is to perform a complete clean, which removes the build directories, the executables and any generated results. This can be accomplished by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean heavy
\end{sphinxVerbatim}

On the other hand, the build directories and executables can be retained while deleting only the results by running the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean results
\end{sphinxVerbatim}

The last variant is where the build directories alone are cleared, retaining the results and the executables, which is done using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u clean
\end{sphinxVerbatim}


\subsection{Plotting Utility}
\label{\detokenize{gridpyfiles/plot:plot}}\label{\detokenize{gridpyfiles/plot::doc}}\label{\detokenize{gridpyfiles/plot:plotting-utility}}
{\color{red}\bfseries{}\textbar{}GridGen\textbar{}} has a builtin plotting utility that allows for plotting of the generated data without the use of external tools. Similar to all the other features, the plotting utility is also accessed through the input file, which is accessed as follows.
\begin{enumerate}
\item {} 
Go to the parent directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}path to \textbar{}GridGen\textbar{}\PYGZgt{}
\end{sphinxVerbatim}

Make sure that you are in the directory that contains the files \sphinxstyleliteralstrong{setup.py}, \sphinxstyleliteralstrong{input\_file.xml}, and the folder \sphinxstyleliteralstrong{src}.

\item {} 
Open the input file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} vi input\PYGZus{}file.xml
\end{sphinxVerbatim}

\end{enumerate}

The section of the inputfile devoted to post-processing is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}PostProcessing}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}plot}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}iPost}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/iPost\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Method}\PYG{n+nt}{\PYGZgt{}}TecPlot\PYG{n+nt}{\PYGZlt{}/Method\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}files}\PYG{n+nt}{\PYGZgt{}}file1.dat\PYG{n+nt}{\PYGZlt{}/files\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}style}\PYG{n+nt}{\PYGZgt{}}k +r \PYGZhy{}c :g \PYGZhy{}.y \PYGZhy{}\PYGZhy{}m\PYG{n+nt}{\PYGZlt{}/style\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}label}\PYG{n+nt}{\PYGZgt{}}Var1\PYG{n+nt}{\PYGZlt{}/label\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}LegendFontSize}\PYG{n+nt}{\PYGZgt{}}16\PYG{n+nt}{\PYGZlt{}/LegendFontSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}FigureSize}\PYG{n+nt}{\PYGZgt{}}10 7\PYG{n+nt}{\PYGZlt{}/FigureSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}AxisLabelSize}\PYG{n+nt}{\PYGZgt{}}21\PYG{n+nt}{\PYGZlt{}/AxisLabelSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}AxisTitleSize}\PYG{n+nt}{\PYGZgt{}}22\PYG{n+nt}{\PYGZlt{}/AxisTitleSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}XTickSize}\PYG{n+nt}{\PYGZgt{}}23\PYG{n+nt}{\PYGZlt{}/XTickSize\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}YTickSize}\PYG{n+nt}{\PYGZgt{}}24\PYG{n+nt}{\PYGZlt{}/YTickSize\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/plot\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/PostProcessing\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Before running the plotting tool it is required to run create the subdirectory output.
\end{sphinxadmonition}


\subsubsection{Options in the plotting module}
\label{\detokenize{gridpyfiles/plot:options-in-the-plotting-module}}\begin{enumerate}
\item {} 
The data files generated from a {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} run (or any external data file) is placed in the \sphinxstyleliteralstrong{output} folder. The name of the file should not have any spaces or special characters (like colon :, quotation marks “” or ”, brackets or parenthesis () {[}{]} etc). The file name is entered into the \sphinxcode{\textless{}files\textgreater{}} field in the input file. If there are more than 1 file, they are entered one after another.

\item {} 
The \sphinxcode{\textless{}style\textgreater{}} entry refers to the line style and color used. There are seven available colors in Python by default: RGBCMYK (Red, Green, Blue, Cyan, Magenta, Yellow and Black). Markers can be placed on the lines using the marker symbols (eg. \sphinxcode{+r} generates a red line with + shaped markers). Line styles can also be changed using appropriate symbols (eg. \sphinxcode{-{-}m} generates a dashed magenta line, while \sphinxcode{-.y} generates a dot-dashed yellow line).

\item {} 
The \sphinxcode{\textless{}label\textgreater{}} entry is to populate the legend. If there are N files for N different variables, then the legend is populated according to the entries in this field.

\item {} 
The remaining entries are to adjust the figure parameters, like font size and figure size.

\end{enumerate}


\subsubsection{Using the plotting module}
\label{\detokenize{gridpyfiles/plot:using-the-plotting-module}}\begin{enumerate}
\item {} 
Enter the names of the data files in the input file

\item {} 
Set the required number of legend entries and line styles, depending on  how many files/variables are being plotted.

\item {} 
Adjust any other plot parameters as required.

\item {} 
The plotting module also provides a generalized feature to make plots from input data. This feature is also accessed through the \sphinxcode{input\_file.xml}. The input data (.dat) files are entered in the \sphinxcode{files} section of the input file. The plotting utility is then accessed using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options \PYGZdq{}\PYGZob{}\PYGZlt{}plot options\PYGZgt{}\PYGZcb{}\PYGZdq{}
\end{sphinxVerbatim}

\end{enumerate}
\begin{quote}

An example of this input for the plotting utility is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options \PYGZdq{}\PYGZob{}\PYGZsq{}title\PYGZsq{}:[\PYGZsq{}RMS Residual for Grid\PYGZsh{}5\PYGZsq{}],
  \PYGZsq{}xlabel\PYGZsq{}:[\PYGZsq{}Number of Iterations\PYGZsq{}],\PYGZsq{}ylabel\PYGZsq{}:[\PYGZsq{}RMS\PYGZsq{}],
  \PYGZsq{}grid\PYGZsq{}:[\PYGZsq{}on\PYGZsq{}],\PYGZsq{}legend\PYGZsq{}:[\PYGZsq{}False\PYGZsq{}],\PYGZsq{}legend\PYGZus{}frame\PYGZsq{}:[\PYGZsq{}True\PYGZsq{}],
  \PYGZsq{}legend\PYGZus{}loc\PYGZsq{}:[\PYGZsq{}lower right\PYGZsq{}]\PYGZcb{}\PYGZdq{}
\end{sphinxVerbatim}
\begin{description}
\item[{The options give flexibility to set the graph title, the labels for the axes, select the columns of data from the input .dat file that we want to plot, set the legend properties, etc.}] \leavevmode
Note that if no options are provided as in the example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}p single\PYGZus{}plot options
\end{sphinxVerbatim}

default options wil be used for the picture name and axes/title labels.
Note that the file and picture options must be provided in the input file,
in the \sphinxcode{\textless{}PostProcessing\textgreater{}} section.

\end{description}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The above command is meant to be used with a generic .dat file, without header, where data is distributed column-wise.
\end{sphinxadmonition}


\subsection{Documentation}
\label{\detokenize{gridpyfiles/documentation:documentation}}\label{\detokenize{gridpyfiles/documentation::doc}}\label{\detokenize{gridpyfiles/documentation:id1}}
The {\color{red}\bfseries{}\textbar{}GridGen\textbar{}} documentation is written using restructured text (reST) Sphinx, and can be manipulated using python routines in Gridpy.


\subsubsection{Building}
\label{\detokenize{gridpyfiles/documentation:building}}
The documentation can be built using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc build
\end{sphinxVerbatim}

This runs Sphinx in the documentation directory, and creates the html files using a make command. The command runs Sphinx twice to make sure references are interlinked properly.


\subsubsection{Viewing}
\label{\detokenize{gridpyfiles/documentation:viewing}}
This command is used for viewing the documentation. It is only available after running the build command above, so that the documentation is created. The documentation can be opened using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc open
\end{sphinxVerbatim}

The documentation requires a compatible version of a web broswer (preferably Google Chrome or Mozilla Firefox). If a compatible browser is installed, the documentation will open when the above command is executed. Otherwise, an error message will be displayed. In case an error message is displayed, the documentation can manually be opened on a web browser from the directory \sphinxstylestrong{\textless{}GridGen parent directory\textgreater{}/doc/\_build/html/index.html}

\begin{sphinxadmonition}{note}{Note:}
If using MAC OS X please be aware to simply run \$ open \sphinxstylestrong{\textless{}GridGen parent directory\textgreater{}/doc/\_build/html/index.html} from the terminal.
\end{sphinxadmonition}


\subsubsection{Cleaning}
\label{\detokenize{gridpyfiles/documentation:cleaning}}
The built documentation can be cleaned (i.e. all the compiled files can be deleted while retaining the source content) using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./setup.py \PYGZhy{}u doc clean
\end{sphinxVerbatim}


\subsubsection{Closing Notes}
\label{\detokenize{gridpyfiles/documentation:closing-notes}}\begin{enumerate}
\item {} 
As with any browser-based content, the appearance of the content is dependent on the capability of the browser to render the elements on the webpage. Depending on the bworser present on the machine, the content may appear different.

\end{enumerate}


\section{Evaluation Cases}
\label{\detokenize{testcases:evaluation-cases}}\label{\detokenize{testcases::doc}}\label{\detokenize{testcases:testcases-main}}

\subsection{Grid testcases}
\label{\detokenize{testcases:grid-testcases}}\label{\detokenize{testcases:test-cases}}

\subsubsection{2D Airfoil Grid Results Summary}
\label{\detokenize{cases/grid_af:d-airfoil-grid-results-summary}}\label{\detokenize{cases/grid_af::doc}}

\paragraph{Grid \#1: Algebraic grid with non-clustered points in y}
\label{\detokenize{cases/grid_af:grid-1-algebraic-grid-with-non-clustered-points-in-y}}
The figure below shows the grid points alignments made by the GridGen code with algebraic grid and uniform grid spacing assumptions at every boundary edges. The interior points were generated by applying linear interpolation based on two opposed pre-specified grid points. Thus the current grid has almost straight lines but with normally inclined angles, which makes a little skewed cells in the leading edge of the air foil. Also we can find a sudden change in cell volume across two grid lines in leading and trailing edges of the airfoil.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{grid1}.png}
\caption{:Grid points alignment of Grid \#1}\label{\detokenize{cases/grid_af:id1}}\end{figure}

The more quantitative analysis is available with grid Jacobian contour on the current mesh. The ‘Jacobian’ here is inherently defined as determinant of inverse grid Jacobian matrix at every single grid point. Thus, it indicates a grid cell volume in 3D and cell area in 2D.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian1}.png}
\caption{:Inverse Grid Jacobian distribution of Grid \#1}\label{\detokenize{cases/grid_af:id2}}\end{figure}


\paragraph{Grid \#2: Algebraic grid with clustered points in y}
\label{\detokenize{cases/grid_af:grid-2-algebraic-grid-with-clustered-points-in-y}}
This grid is based on the same approach for Grid \#1. The only change in this grid was to apply gradually clustered grid points downward at left and right boundaries. Note that the linear interpolation of \(x\)-coordinates along the each vertical line is made only on the basis of j-index as formulated earlier. The effect of this is to make x coordinate shifting along the vertical line is identical for every point. Thus it leads to the somewhat much shifting for concentrated grid points in \(y\)-direction. Now we can observe non-linear grid lines in j-direction. This makes grid less skewer in the leading edge of the airfoil.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{grid2}.png}
\caption{:Grid points alignment of Grid \#2}\label{\detokenize{cases/grid_af:id3}}\end{figure}

The grid Jacobian contour is shown below. Applying grid stretching along the \(y\) direction gives big cell volume distribution. Change in volume along the bottom edge looks less significant even in the leading edge. Since, however, the grid spacing is not changed in \(x\) direction from Grid \#1 alignment, we could expect some error in flux throught the cell face at leading edge. The same situation happens at the trailing point of the airfoil. In some points, this grid alignment is more reliable for this geometry because the significantly high gradient of flow velocity will only take place in the leading edge and therfeore we need more dense grid points in this region.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian2}.png}
\caption{:Inverse Grid Jacobian distribution of Grid \#2}\label{\detokenize{cases/grid_af:id4}}\end{figure}


\paragraph{Grid \#3: Elliptic grid with clustered points in y \& no control terms}
\label{\detokenize{cases/grid_af:grid-3-elliptic-grid-with-clustered-points-in-y-no-control-terms}}
The grid shown below is made by the elliptic Poisson equations with clustered grid points in vertical direction. As expected, the Poisson equation with no control terms draws grid alignments that resemble iso-stream lines and iso-potential lines around the airfoil body. This is because the set of Poisson equation is exactly the same as a set of stream function and potention function when the control terms are ignored.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{grid3}.png}
\caption{:Grid points alignment of Grid \#3}\label{\detokenize{cases/grid_af:id5}}\end{figure}

However, it is expected that curved lines right at the inlet edge and outlet edge are not aligned with the inlet flow. This misaligment could cause issues in the flux evaluation of flow properties across the j-constant lines and thus it would make numerical errors. From the grid Jacobian contour result, sudden change in cell volume along the flow direction can be found. Maximum and minimum cell volume are found at left and right top edge and bottom edge, respectively.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian3}.png}
\caption{:Inverse Grid Jacobian distribution of Grid \#3}\label{\detokenize{cases/grid_af:id6}}\end{figure}


\paragraph{Grid \#4: Elliptic grid with clustered points in y \& control terms}
\label{\detokenize{cases/grid_af:grid-4-elliptic-grid-with-clustered-points-in-y-control-terms}}
The problem that arise in Grid \#3 case was able to be resolved by adding control terms in the Poisson equation. From the mesh shape of Grid \#4 shown below, it can be found that adding control terms plays an important role in improving grid orthogonality. Thus now we have better grid aligment especially along the flow stream lines that can be expected intuitively. Even though there is a significant change in grid size along the vertical line, it may not act as a critical issue for numerical accuracy because the flux in vertical direction will not be critical.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{grid4}.png}
\caption{:Grid points alignment of Grid \#4}\label{\detokenize{cases/grid_af:id7}}\end{figure}

In this grid, we can find a severely skewed cell in the leading edge of airfoil. This is more severe than Grid \#3. Making orthogonality for the vertical lines cause more vertically stand i-constant lines, hence it leads to the sharp angle between airfoil arc and i-constant line anchored at the leading edge.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian4}.png}
\caption{: Inverse Grid Jacobian distribution of Grid \#4}\label{\detokenize{cases/grid_af:id8}}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian4_zoom}.png}
\caption{: Zoomed Inverse Grid Jacobian distribution of Grid \#4 over airfoil surface}\label{\detokenize{cases/grid_af:id9}}\end{figure}


\paragraph{Grid \#5: Improved elliptic grid}
\label{\detokenize{cases/grid_af:grid-5-improved-elliptic-grid}}
Based on the above grid results we can conclude that the best grid quality is Grid\#4. Although Grid\#4 shows promixing results, the following issues are still to be resolved:
\begin{enumerate}
\item {} 
At both the leading edge and trailing edge of the airfoil there is still some sudden variation in the cell size.

\item {} 
Large variation in skeweness of the grid is observed when control terms are applied.

\end{enumerate}

To handle the above problems the following approach is implemented:
\begin{enumerate}
\item {} 
Maintain the grid stretched along the y direction with the same Cy.

\item {} 
Provide smooth cell size transition along the segments FE,ED, and DC by employing testing varying values of Cy.

\item {} 
Provide new Cy parameters for stretching in Psi and Phi

\end{enumerate}

The following values of Cy were chosen for the best grid quality:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Method
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Cy
\unskip}\relax \\
\hline
Stretching along y
&
2.0
\\
\hline
Stretching along FE
&
-1.0
\\
\hline
Stretching along ED
&
1.0
\\
\hline
Stretching along DC
&
0.001
\\
\hline
Stretching in Phi
&
-11.0
\\
\hline
Stretching in Psi
&
0.001
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

According to the above table a stretching method was applied to the bottom segment of the grid in order to improve the smoothness of the cell variation in area. This adjustment in the values of Cy allowed to increase the number of grid points near the leading edge and trailing edge of the airfoilf as we expect to obtain greater variation in flow properties along this section of the flow field.
A note must be made regarding the segment AB. This portion of the grid was left uniform as we do not expect to have large variation in flow properties in such region of the grid.

Furthermore, stretching for \(\phi\) and \(\psi\) was applied in order to improve the grid alingment along the surface of the airfoil. A negative value for \(\psi\)  reduces the skewness of nearby cells at the leading and trailing edge. Below the \(\psi\)  field is compared between the original grid with constant Cy and the new improved grid.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\begin{itemize}
\item {} 
Initial Grid ‘cy = 0.001’

\end{itemize}
&\begin{itemize}
\item {} 
Grid 5 Psi Field

\end{itemize}
\\
\hline
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{psi1}.png}
&
\noindent\sphinxincludegraphics[width=0.900\linewidth]{{psi5}.png}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

After completion, the overall improved grid and inverse Jacobian are presented below:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{grid5}.png}
\caption{:Grid \#5}\label{\detokenize{cases/grid_af:id10}}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{jacobian5}.png}
\caption{:Inverse Grid Jacobian distribution of Grid \#5}\label{\detokenize{cases/grid_af:id11}}\end{figure}

As shown from the inverse of the Jacobian, most of the smalle area cells are located along the surface of the airfoil where the flow prperties significantly change.


\paragraph{Residual Convergence}
\label{\detokenize{cases/grid_af:residual-convergence}}
The residual is one of the most fundamental measures of an iterative solution’s converence, as it directly quantifies the error in the solution. The image below show the RMS residual for the last three grids generated through this code.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{RMSlog}.png}
\caption{:RMS Residual}\label{\detokenize{cases/grid_af:id12}}\end{figure}

It can be noted that as we apply the control terms for the elliptical grid generation, the number of iterations required for the RMS residual to approach the desired limit is reduced.



\renewcommand{\indexname}{Index}
\printindex
\end{document}